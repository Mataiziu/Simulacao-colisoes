# Codigo do programa feito no site codeskulptor com o link: https://py3.codeskulptor.org/#user306_kJwp0katSg_9.py

import simplegui
import random
import math

screen_size = 500

screen = [16 * screen_size / 9, screen_size]

grid_n = 35
grid_distances = [screen_size / grid_n, screen_size / grid_n]
grid_point_zero = [0, 0]
grid_index = []

for i in range(grid_n):
    index = []
    for j in range(grid_n):
        index += [[i, j, []]]
    grid_index += [index]
    
ball_radius = 3
ball_border = 0.1

ball = [[screen_size - ball_radius, screen_size / 2]]
ballMFP = []
ball_velocity = []
ball_color = []
ball_collided = []

new_ball_position = [screen_size - ball_radius, screen_size / 2]
can_new = True

need_new_ball = 0

heat = 2.5

pause = False
red_time = 1
red_time_status = False

FPS = 0

pressure = 0.0
pressure_time = 0

second = 0

print(f'Second = {second}, amount of balls = {len(ball_velocity)}, heat = {heat} pressure per sec = {pressure}, FPS = 60')

# Tell Where is the ball in the grid
def where_balls_grid():
    global grid_n, grid_index, grid_distances
        
    # Clear the grid
    for i in range(grid_n):
        for j in range(grid_n):
            grid_index[i][j][2] = []
            
    # Add ball to your grid
    for i in range(len(ball)):
        
        nx = int(ball[i][0] / grid_distances[0])
        ny = int(ball[i][1] / grid_distances[1])
        
        this_index = [nx, ny]
        
        grid_index[this_index[1]][this_index[0]][2] += [i]


# Distance between two balls
def distance(ball1, ball2):
    return (((ball1[0] - ball2[0]) ** 2) + ((ball1[1] - ball2[1]) ** 2))** 0.5


# Gives velocity vectors after collision
def collision(v1, v2, p1, p2):
    # Vector at the ball collision center
    vector = [p2[0] - p1[0], p2[1] - p1[1]]

    # Finding unit normal and unit tangent vector
    module = ((vector[0] ** 2) + (vector[1] ** 2))** 0.5
    k = [vector[0] / module, vector[1] / module]

    v_relative = [v1[0] - v2[0], v1[1] - v2[1]]

    # Creating the velocity vectors onto the unit normal and unit tangent vectors
    v_normal = v_relative[0] * k[0] + v_relative[1] * k[1]

    v_normal = [k[0] * v_normal, k[1] * v_normal]

    v1 = [v1[0] - v_normal[0], v1[1] - v_normal[1]]
    v2 = [v2[0] + v_normal[0], v2[1] + v_normal[1]]

    # Returning both velocities
    return v1, v2

# Check collisions
def general_collision():
    global grid_index, ball_velocity, can_new, ball_collided
    
    # Put balls in grid
    where_balls_grid()
    
    # For every grid
    for k in grid_index:
        for l in k:
            # Exept left and top grids
            if 0 < l[0] and 0 < l[1]:
                
                # Check the grid and the neighbor on left, top and top-left
                grid_around = [grid_index[l[0] - 1][l[1] - 1][2] + grid_index[l[0]][l[1] - 1][2] +  
                               grid_index[l[0] - 1][l[1]][2]     + grid_index[l[0]][l[1]][2]      ]
                
                # If there is more than 1 ball in the grid
                if len(grid_around[0]) > 1:
                    
                    # For every ball in grid
                    for n in grid_around[0]:
                        for i in grid_around[0]:
                            
                            # If ball don't collided
                            if n not in ball_collided and i not in ball_collided:
                                
                                # Collision for entering balls
                                if n == len(ball_velocity) or i == len(ball_velocity):
                                
                                    if n != i and distance(ball[n], ball[i]) <= 4 * ball_radius:
                                        can_new = False
                                
                                # General collision
                                else:
                                    
                                    if n != i and distance(ball[n], ball[i]) <= 2 * ball_radius:
                                        
                                        ball_velocity[n], ball_velocity[i] = collision(ball_velocity[n], ball_velocity[i], ball[n], ball[i])
                                        
                                        ball_collided.append(n)
                                        ball_collided.append(i)
                                        
                                        #mean_free_path(n)
                                        #mean_free_path(i)
    
    # Clear the collision status of the balls
    ball_collided = []
    

# Mean free path
def mean_free_path(n):
    global ballMFP
    
    MFP = distance(ball[n], ballMFP[n])
    
    #print(MFP)

    ballMFP[n] = list(ball[n])


# Handler to draw on canvas
def draw(canvas):

    # Drawing each ball
    for n in range(len(ball) - 1):
        canvas.draw_circle([ball[n][0], ball[n][1]], ball_radius, ball_border, 'Transparent', ball_color[n])

    canvas.draw_polygon([[screen_size, screen_size], [screen[0], screen_size], [screen[0], 0], [screen_size, 0]], 2, 'Transparent', 'Black')
    canvas.draw_polygon([[screen_size, screen_size], [0, screen_size], [0, 0], [screen_size, 0]], 2, 'White', 'Transparent')
    canvas.draw_line([screen_size, (screen_size / 2) + ball_radius], [screen_size, (screen_size / 2) - ball_radius], 4, 'Blue')
    
    for i in range(grid_n):
        canvas.draw_line((0, grid_distances[0] * i), (screen_size, grid_distances[0] * i), 1, 'Lightgray')
        canvas.draw_line((grid_distances[1] * i, 0), (grid_distances[1] * i, screen_size), 1, 'Lightgray')
    
    # pause
    if pause:
        canvas.draw_polygon([[screen[0] - 250, 50], [screen[0] - 250, 0], [screen[0] - 300, 0], [screen[0] - 300, 50]], 2, 'White', 'White')

    else:
        canvas.draw_polygon([[screen[0] - 250, 50], [screen[0] - 250, 0], [screen[0] - 300, 0], [screen[0] - 300, 50]], 2, 'White', 'Black')

    canvas.draw_polygon([[screen[0] - 270, 35], [screen[0] - 270, 15], [screen[0] - 260, 15], [screen[0] - 260, 35]], 2, 'White', 'Black')
    canvas.draw_polygon([[screen[0] - 280, 35], [screen[0] - 280, 15], [screen[0] - 290, 15], [screen[0] - 290, 35]], 2, 'White', 'Black')

    # ball+, ball-
    canvas.draw_polygon([[screen[0] - 50, 50], [screen[0] - 50, 0], [screen[0] - 100, 0], [screen[0] - 100, 50]], 2, 'White', 'Transparent')
    canvas.draw_polygon([[screen[0] - 2, 50], [screen[0] - 2, 0], [screen[0] - 50, 0], [screen[0] - 50, 50]], 2, 'White', 'Transparent')

    canvas.draw_text('+ Ball', (screen[0] - 90, 30), 12, 'White')
    canvas.draw_text('- Ball', (screen[0] - 40, 30), 12, 'White')

    # ball+10, ball-10
    canvas.draw_polygon([[screen[0] - 50, 50], [screen[0] - 50, 100], [screen[0] - 100, 100], [screen[0] - 100, 50]], 2, 'White', 'Transparent')
    canvas.draw_polygon([[screen[0] - 2, 50], [screen[0] - 2, 100], [screen[0] - 50, 100], [screen[0] - 50, 50]], 2, 'White', 'Transparent')

    canvas.draw_text('+10 Ball', (screen[0] - 100, 80), 12, 'White')
    canvas.draw_text('-10 Ball', (screen[0] - 50, 80), 12, 'White')

    # heat+, heat-
    canvas.draw_polygon([[screen[0] - 50, 150], [screen[0] - 50, 200], [screen[0] - 100, 200], [screen[0] - 100, 150]], 2, 'White', 'Transparent')
    canvas.draw_polygon([[screen[0] - 2, 150], [screen[0] - 2, 200], [screen[0] - 50, 200], [screen[0] - 50, 150]], 2, 'White', 'Transparent')

    canvas.draw_text('+ Heat', (screen[0] - 90, 180), 12, 'White')
    canvas.draw_text('- Heat', (screen[0] - 40, 180), 12, 'White')

    # heat+1, heat-1
    canvas.draw_polygon([[screen[0] - 50, 250], [screen[0] - 50, 200], [screen[0] - 100, 200], [screen[0] - 100, 250]], 2, 'White', 'Transparent')
    canvas.draw_polygon([[screen[0] - 2, 250], [screen[0] - 2, 200], [screen[0] - 50, 200], [screen[0] - 50, 250]], 2, 'White', 'Transparent')

    canvas.draw_text('+1 Heat', (screen[0] - 100, 230), 12, 'White')
    canvas.draw_text('-1 Heat', (screen[0] - 50, 230), 12, 'White')

    # general text
    canvas.draw_text('BPM = ' + str(int(pressure)), (screen_size + 20, 20), 12, 'White')
    canvas.draw_text('Balls = ' + str(len(ball_velocity)), (screen_size + 20, 40), 12, 'White')
    canvas.draw_text('Heat = ' + str(heat), (screen_size + 20, 60), 12, 'White')


# Handler to mouse click
def mouse_handler(position):
    global ball_color, need_new_ball, heat, pause

    mouse_position = [position[0], position[1]]

    # pause
    if screen[0] - 300 < mouse_position[0] < screen[0] - 250 and 0 < mouse_position[1] < 50:
        if not pause:
            work.stop()
            timer.stop()

            pause = True

        else:
            work.start()
            timer.start()

            pause = False
    
    elif screen[0] - 100 < mouse_position[0] < screen[0] - 50:
        # ball +
        if 0 < mouse_position[1] < 50:
            need_new_ball += 1
        
        # ball + 10
        elif 50 < mouse_position[1] < 100:
            need_new_ball += 10
            
        # heat + 0.1
        elif 150 < mouse_position[1] < 200:
            heat += 0.1
            heat = round(heat, 1)
        
        # heat + 1
        elif 200 < mouse_position[1] < 250:
            heat += 1
            heat = round(heat, 1)
    
    
    elif screen[0] - 50 < mouse_position[0] < screen[0]:
        # ball -
        if 0 < mouse_position[1] < 50:
            need_new_ball -= 1
        
        # ball - 10
        elif 50 < mouse_position[1] < 100:
            need_new_ball -= 10
            
        # heat - 0.1
        elif 150 < mouse_position[1] < 200:
            if heat != 0:
                heat -= 0.1
                heat = round(heat, 1)
        
        # heat - 1
        elif 200 < mouse_position[1] < 250:
            if heat > 1:
                heat -= 1
                heat = round(heat, 1)

            else:
                heat = 0
    
    
    # Coloring in pause
    elif pause:
        for n in range(len(ball_velocity)):
            if distance(mouse_position, ball[n]) <= ball_radius:
                if ball_color[n] != 'Red':
                    ball_color[n] = 'Red'

                else:
                    ball_color[n] = 'White'


# Work in iteration
def work_handler():
    global ball, ball_velocity, ballMFP, ball_color, can_new, need_new_ball, pressure_time, red_time_status, red_time, FPS

    can_new = True
    
    general_collision()		# comment this line if you don't want collision
    
    # For every ball
    for n in range(len(ball_velocity)):

        # For print the velocity of selected balls
        if ball_color[n] == 'Red' and not pause:
            print(f'{red_time} Bola {n} = ', ball_velocity[n])
            time_status = True
            
        
        # Moving the ball

        ball[n][0] += ball_velocity[n][0]
        ball[n][1] += ball_velocity[n][1]

        # Wall collision

        if ball[n][0] <= ball_radius:
            
            ball_velocity[n][0] = heat  # Heat in the left wall
            
            ball[n][0] = (2 * ball_radius) - ball[n][0]
            
            mean_free_path(n)
            pressure_time += 1
        
        elif ball[n][0] >= screen_size - ball_radius:
            
            ball_velocity[n][0] = -ball_velocity[n][0]
            ball[n][0] = (2 * (screen_size - ball_radius)) - ball[n][0]
            
            mean_free_path(n)
            pressure_time += 1
        
        if not ball_radius < ball[n][1] < screen_size - ball_radius:
            ball_velocity[n][1] = -ball_velocity[n][1]
            
            if ball[n][1] <= ball_radius:
                ball[n][1] = (2 * ball_radius) - ball[n][1]
            
            elif ball[n][1] >= screen_size - ball_radius:
                ball[n][1] = (2 * (screen_size - ball_radius)) - ball[n][1]
            
            mean_free_path(n)
            pressure_time += 1

    # time of the print
    if red_time_status:
        red_time += 1
        red_time_status = False

    # if it's all ok to create a new ball
    if can_new and need_new_ball > 0:

        ball.append(list(new_ball_position))
        ballMFP.append(list(new_ball_position))
        ball_velocity.append([random.triangular(-1, -0.01), random.triangular(-1, 1)])
        ball_color.append('White')

        need_new_ball -= 1

    elif need_new_ball < 0:
        if len(ball_velocity) > 0:

            y = random.randint(0, len(ball_velocity) - 1)
            ball.pop(y)
            ballMFP.pop(y)
            ball_velocity.pop(y)
            ball_color.pop(y)

            need_new_ball += 1
        else:

            ball = [[screen_size - ball_radius, screen_size / 2]]
            ballMFP = [[screen_size - ball_radius, screen_size / 2]]
            ball_velocity = []
            ball_color = []

            need_new_ball = 0
            
    FPS += 1

# Trigger per minute for pressure measure
def timer_handler():
    global second, pressure, pressure_time, FPS
    
    second += 1
    pressure = (pressure_time + pressure) / 2
    pressure_time = 0

    print(f'Sec = {second}, nB = {len(ball_velocity)}, heat = {heat}, ppm = {round(pressure,1)}, FPS = {FPS}')
    
    FPS = 0

# Create a frame and assign callbacks to event handlers
frame = simplegui.create_frame("Home", screen[0], screen[1])
frame.set_draw_handler(draw)
frame.set_mouseclick_handler(mouse_handler)

# Start the frame animation
frame.start()

# Timer for pressure per minute
timer = simplegui.create_timer(1000, timer_handler)
timer.start()

# Timer for pressure per minute
work = simplegui.create_timer(1, work_handler)
work.start()
